# 06 | 用“等待-通知”机制优化循环等待

## 背景
由上一篇文章你应该已经知道，在破坏占用且等待条件的时候，如果转出账本和转入账本不满足同时在文件架上这个条件，就用死循环的方式来循环等待，核心代码如下：     
```text
while(actr.apply(this,target)) {
    //执行
}
```
点评：apply方法耗时很短时时，锁冲突不大时，还好，毕竟能一次获取到转出账本和转入账本；但是一旦apply锁冲突比较大且耗时很长时，
这种方式很消耗CPU

这种场景下，最好的解决方案是：等待、通知机制（相当于你不用一直尝试，如果满足条件我通知你，一直死循环多累鸭）

那么java语言是否支持这种"等待-通知"机制呢？答案是肯定的，毕竟长期霸占语言排行榜第一😂      

## 一个完整的等待-通知机制：
线程首先获取锁，获取到锁后当线程要求条件不满足时，释放互斥锁，进入等待状态；当要求的条件满足时，通知等待的线程重新获取互斥锁！  


## 正餐：用 synchronized 实现等待 - 通知机制        
在java语言里，有多种方式可以实现等待-通知机制，比如synchronized配合wait()/notify()/notifyAll()就能实现。

具体如何实现：

用synchronized实现互斥锁你已经很熟悉了，如下图，左边有一个等待队列，同一时刻只允许一个线程进入临界保护区， 
当一个线程进入临界保护区后，其余线程就只能在左等待队列里等待了。【这个等待队列和互斥锁是一对一的关系，每个互斥锁都有自己独立的等待队列。】
![](19-wait()工作原理.png)      

在并发程序中，当一个线程进入临界区后，由于某些条件不满足，需要进入等待状态，Java 对象的 wait() 方法就能够满足这种需求。      

解释：如上图所示，
- 1、当调用 wait() 方法后，当前线程就会被阻塞，并且进入到右边的等待队列中，这个等待队列也是互斥锁的等待队列。
- 2、线程在进入等待队列的同时，会释放持有的互斥锁，线程释放锁后，其他线程就有机会获得锁，并进入临界区了。

问题来了：那线程要求的条件满足时，该怎么通知这个等待的线程呢？很简单，就是 Java 对象的 notify() 和 notifyAll() 方法。       
如下图：当条件满足时调用 notify()，会通知右等待队列（互斥锁的等待队列）中的线程，告诉它条件曾经满足过。
![](20-notify()工作原理.png)

为什么说是曾经满足过呢？因为notify() 只能保证在通知时间点，条件是满足的。而被通知线程的执行时间点和通知的时间点基本上不会重合，所以当线程执行的时候，很可能条件已经不满足了（保不齐有其他线程插队）。这一点你需要格外注意。      
（高仔白话解释：张三来我这里买东西，我告诉张三东西已经卖完了，你旁边等会吧；过了10分钟供货员送来了1件东西，我喊了声张三你来吧，有货了，张三这时候往过走，但是保不齐这时李四正好赶前面先来了把货
买走了，等张三过来时，我只能告诉他：没货了！ 你看，我通知他时他条件是满足的，等他真正过来时条件不一定满足，所以说是曾经满足；为什么通知时间和执行时间一般不一样呢？"你往过走不需要时间吗？或者你和李四同时过来不需要争论一番到底谁先来吗"）

另外注意：wait()会主动释放锁，也就是wait()后你需要重新获取互斥锁（高仔白话解释:你到一边等待时，你刚才排队的就不算了，等你回来时重新排）

注意：     
> 上面我们一直强调 wait()、notify()、notifyAll() 方法操作的等待队列是互斥锁的等待队列，
所以如果 synchronized 锁定的是 this，那么对应的一定是 this.wait()、this.notify()、this.notifyAll()；
如果 synchronized 锁定的是 target，那么对应的一定是 target.wait()、target.notify()、target.notifyAll() 。 
而且 wait()、notify()、notifyAll() 这三个方法能够被调用的前提是已经获取了相应的互斥锁，所以我们会发现 wait()、notify()、notifyAll() 都是在 synchronized{}内部被调用的。  
如果在 synchronized{}外部调用，或者锁定的 this，而用 target.wait() 调用的话，JVM 会抛出一个运行时异常：java.lang.IllegalMonitorStateException
（高仔白话解释：synchronized相当于柜员，wait()相当于等待区，notify相当于通知一声；首先，你要往等待区坐一定是得经过柜员即wait必须在synchronized里 
其次，张三经过柜员后只能坐在给张三指定的等待区， 另外，张三没来过那你柜员就不能喊张三，人家就没来过你还喊人家你是有毛病吗？即notify必须是在synchronized里）


## 小试牛刀：一个更好地资源分配器
等待 - 通知机制的基本原理搞清楚后，我们就来看看它如何解决一次性申请转出账户和转入账户的问题吧。
在这个等待 - 通知机制中，我们梳理一下流程：     
1.互斥锁：上一篇文章我们提到 Allocator 需要是单例的，所以我们可以用 this 作为互斥锁。        
2.线程要求的条件：转出账户和转入账户都没有被分配过。
3.何时等待：线程要求的条件不满足就等待。
4.何时通知：当有线程释放账户时就通知。        

搞清楚后，我们快速完成下面的代码        
```text
while(条件不满足) {
    wait();
}
```
> 利用这种范式可以解决上面提到的条件曾经满足过这个问题。因为当 wait() 返回时，有可能条件已经发生变化了，曾经条件满足，但是现在已经不满足了，所以要重新检验条件是否满足。范式，意味着是经典做法，所以没有特殊理由不要尝试换个写法。后面在介绍“管程”的时候，我会详细介绍这个经典做法的前世今生。

```java
/**
 * @Author gaoqiangwei
 * @Date 2020/5/30 00:00
 * @Description
 */
public class Allocator {
    private List<Object> als;
    //一次性申请所有资源
    synchronized boolean apply(Object from,Object to)throws Exception {
        //经典写法
        while (als.contains(from) || als.contains(to)) {
            wait();
        }
        als.add(from);
        als.add(to);
        return true;
    }
    //归还资源
    synchronized void free(Object from,Object to) {
        als.remove(from);
        als.remove(to);
        notifyAll();
    }
}
```

## 尽量使用notifyAll()
在上面的代码中，我用的是 notifyAll() 来实现通知机制，为什么不使用 notify() 呢？这二者是有区别的:        
- notify() 是会随机地通知等待队列中的一个线程，
- 而 notifyAll() 会通知等待队列中的所有线程。        
从感觉上来讲，应该是 notify() 更好一些，因为即便通知所有线程，也只有一个线程能够进入临界区。但那所谓的感觉往往都蕴藏着风险，实际上使用 notify() 也很有风险，它的风险在于可能导致某些线程永远不会被通知到。     

举例：     
假设我们有资源 A、B、C、D，线程 1 申请到了 AB，线程 2 申请到了 CD，此时线程 3 申请 AB，会进入等待队列（AB 分配给线程 1，线程 3 要求的条件不满足），线程 4 申请 CD 也会进入等待队列。我们再假设之后线程 1 归还了资源 AB，如果使用 notify() 来通知等待队列中的线程，有可能被通知的是线程 4，但线程 4 申请的是 CD，所以此时线程 4 还是会继续等待，而真正该唤醒的线程 3 就再也没有机会被唤醒了。

【注意】所以除非经过深思熟虑，否则尽量使用 notifyAll()。


## 总结       
等待 - 通知机制是一种非常普遍的线程间协作的方式。工作中经常看到有同学使用轮询的方式来等待某个状态，其实很多情况下都可以用今天我们介绍的等待 - 通知机制来优化。      
Java 语言内置的 synchronized 配合 wait()、notify()、notifyAll() 这三个方法可以快速实现这种机制，但是它们的使用看上去还是有点复杂，所以你需要认真理解等待队列和 wait()、notify()、notifyAll() 的关系。

（Java 语言的这种实现，背后的理论模型其实是管程，这个很重要，不过你不用担心，后面会有专门的一章来介绍管程。现在你只需要能够熟练使用就可以了。）

## 课后思考
很多面试都会问到，wait() 方法和 sleep() 方法都能让当前线程挂起一段时间，那它们的区别是什么？现在你也试着回答一下吧。





